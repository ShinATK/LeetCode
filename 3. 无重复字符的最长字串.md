#leetcode
# 滑动窗口
题目：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
	输入: s = "abcabcbb"
	输出: 3 
	解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:
	输入: s = "bbbbb"
	输出: 1
	解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:
	输入: s = "pwwkew"
	输出: 3
	解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
- 我的答案：
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
	    stack = []
	    count = 0
	    for each in s:
		    while each in stack:
			    stack.pop(0)
			stack.append(each)
			count = max(len(stack), count)
		return count
```
- 滑动窗口：
	- 找到一个子串（不含重复字符）s[left, right]
	- 为了寻找最长子串，右边界right右移，扩展子串长度
		- 若此时s[right+1]根子串s[left, right]比较，s[right+1]与子串中每个字符都不同，则将s[right+1]加入子串
		- 若s[right+1]与子串中某个字符相同，则将左边界left右移，直到剔除那个重复的字符
	- 从left到right这个区间形成一个滑动窗口，窗口不停向前滑动，寻找不含重复字符的最长子串，记录子串的长度，并求最长的子串长度
```python
class Solution:
	def lengthOfLongestSubstring(self, s:str) -> int:
		l, r = 0, -1 # 左右边界
		length = len(s)
		res, freq = 0, []
		while l < length: # 左边界移动到最右端
			if r+1 < length and s[r+1] not if freq: # 判断右边界右侧的元素位置与右侧的元素是否在子串中
				r += 1 # 无重复子串，右边界右移
				freq.append(s[r]) # 无重复则扩展子串
			else:
				freq.pop(0) # 重复则循环pop直到剔除重复
				l += 1
			res = max(res, r-l+1) # 存储最长子串长度
		return res
```
- **双90解答：**
	- 求解思路：
		- 字符串优先考虑：双指针求解
		- 可能会出现很多重复字符len(set(s)) <= 1优化题解
		- 双指针代码模板
			- 无重复：移动右指针
			- 有重复：移动左指针
			- 同时需要注意指针的取值：
```python
class Solution:
	def lengthOfLongestSubstring(self, s: str)->int:
		if len(set(s)) <= 1:
			return len(set(s))
		left = right = 0
		n = len(s) - 1
		max_num = 0
		while left < n or right < n: # 左右指针只要有一个没有到达等于n的位置就继续运行（目的是遍历所有可能的无重复元素的长度）
			# 指针重合则移动右指针
			if left==right:
				right += 1
			# 判断右指针是否到达最右端以及判断是否有重复元素
			while right <= n and s[right] not in s[left:right]:
				right += 1
			# 出现重复元素或右指针遍历到最后一个元素时，存储长度
			max_num = max_num if max_num > right - left else right - left
			# 移动左指针直到s[left, right]满足s[right] not in s[left:right]
			left += 1
		return max_num
```