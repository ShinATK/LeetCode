
# 选择排序

## 算法步骤

- 第一次遍历中，记录最大（最小）元素位置，并将其放到序列的首位
- 第二次遍历中，对**未排序**部分重复上述步骤，并放在排序序列的末尾
- 重复直至完成

## 代码实现

```cpp
void SelectionSort(vector<int>& nums){
    for(int i=0;i<nums.size()-1;++i){
        int min = i;
        for(int j=i+1;j<nums.size();++j){
            if(nums[j] < nums[min])
                min = j;
        }
        std::swap(nums[i], nums[min]);
    }
}
```

外层 for 循环当前位置之前都是已经排序完毕的位置，所以需要在之后找到最小（最大）元素，并交换到当前位置

所以这里的内层 for 循环目的就是找到未排序部分中最小（最大）元素，并记录下标

## 复杂度分析

- 时间复杂度：由于固定需要内外嵌套遍历，所以是 $O(n^2)$
- 空间复杂度：$O(1)$

