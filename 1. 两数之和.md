#leetcode #哈希法

题目：
	给定一个整数数组nums和一个正数目标值target，请你在数组中找出和为目标值target的那两个整数，并返回它们的数组下标。
	你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现
	你可以按任意顺序返回答案。
	示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]

- 自己的答案：暴力寻找两个元素相加为target的下标
```python
class Solution:
	def twoSum(self, nums: List[int], target: int) -> List[int]:
		n = len(nums)
		for i in range(n-1):
			for j in range(i+1, n):
			if nums[i] + nums[j] == target:
			return [i, j]
```
- 参考：思路从*找到相加等于目标值的两个元素*转为*找到元素为目标值减去另一个元素*。即寻找target-num。**重点：存放遍历过的元素，从保存的集合中寻找满足target-num的元素，如果集合中不存在，则可能是没有遍历到（不用考虑不存在和为target的情况），此时只需要将目前的元素加入集合中，继续后续遍历。**
```python
class Solution:
	def twoSum(self, nums: List[int], target: int) -> List[int]:
		records = dict()
		for idx, val in enumerate(nums):
			if target-val not in records:
				records[val] = idx
			else:
				return [records[target - val], idx]
```
- 特殊情况：
	- 输入：[3, 3]，target=6。如果采用[nums.index(val), nums.index(target-val)]，返回的结果是[0, 0]，因为index会返回第一个等于给定value的位置。而上述使用字典的解法，则因为return中的两个下标其实是分开的，前一个records[]是之前已经遍历过的元素对应的下标，后一个idx为刚刚遍历到的。即可以避免了同一个位置的同一个元素自身相加满足target，又防止下标出现重合。但整体思路应该还是从两个集合中选取元素（但字典查找要更快），因为既要返回val的下标，又要返回target-val的下标。

>首先我在强调一下 什么时候使用**哈希法**，*当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。*

本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。
那么我们就应该想到使用哈希法了。
因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。

思路上：先存储遍历过的元素，那么如果第二次遍历到的元素的对应元素存在于先前存储的集合中，则说明此时遍历到的元素为a+b=target的第二个元素b，a则早已经位于遍历过的集合中了。而我之前的思路总是想着，先随便找到一个元素a，然后找target-a也就是b存不存在，这就导致了一个问题，我需要遍历两次。但如果按照之前的思路，遍历时寻找先前遍历的是否存在，二者其实本质上都是重复便利，但问题在于，这时我寻找的先前遍历的集合，可以利用字典来缩短寻找元素的时间，并且避免了列表中index获取下标的重复情况。