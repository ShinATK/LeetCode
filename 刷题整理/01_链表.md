#leetcode #算法 #链表

## 排序链表

1. 堆栈法

按链表顺序依次访问，并将节点值存储至栈内，最后对栈进行排序即可。

```python
class Solution:
    def reverseBookList(self, head: Optional[ListNode]) -> List[int]:
        stack = []
        while head:
            stack.append(head.val)
            head = head.next
        return stack[::-1]
```

**复杂度分析**：
- 时间复杂度$O(N)$： 入栈和出栈共使用$O(N)$时间
- 空间复杂度$O(N)$：辅助栈 `stack` 和数组 `res` 共使用$O(N)$的额外空间。

2. 递归法

先递归至链表末端；反向回溯时，依次将节点值加入列表，即可实现倒序输出
- 终止条件：`head == None` 时停止，返回空列表
- 递推：通过 `head.next` 访问下一个节点
- 回溯阶段：返回当前 list + 当前节点值 head.val

```python
class Solution:
    def reverseBookList(self, head: Optional[ListNode]) -> List[int]:
        return self.reverseBookList(head.next) + [head.val] if head else []
```

**复杂度分析**：
- 时间复杂度$O(N)$：遍历链表，递归N次
- 空间复杂度$O(N)$：系统递归需要使用$O(N)$的栈空间

## 倒序链表

1. 双指针迭代思路：

- 初始化双指针：一前pre一后cur
- 循环条件：cur为真。
	- 将cur重新指向前一个节点pre
	- pre=cur，cur=cur.next
- 当cur指向null，表示访问完毕
- 返回此时pre

```python
class Solution:
    def trainningPlan(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur = head
        pre = None
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre
```

**复杂度分析**：
- 时间复杂度$O(N)$：N为链表长度
- 空间复杂度$O(1)$：双指针占用常数大小空间

2. 递归思路

递归遍历链表，越过尾节点后终止递归，回溯时更改各节点的 `next` 指向

- 建立递归函数 `recur(cur, pre)` ：
	- 终止条件：`cur` 为空，返回尾节点 `pre`
	- 递归后继节点：记录返回值为 `res`
	- 修改当前节点 `cur` 引用指向前驱节点 `pre`
	- 返回反转链表的头节点`res`
- `trainningPlan(head)` 函数：
	- 调用并返回 `recur(head, null)` 。传入 `null` 是因为反转链表后，`head` 节点指向 `null` ；

```python
class Solution:
    def trainningPlan(self, head: ListNode) -> ListNode:
        def recur(cur, pre):
            if not cur: return pre     # 终止：终止条件
            res = recur(cur.next, cur) # 递归：递归后继节点
            cur.next = pre             # 回溯：修改节点引用指向
            return res                 # 返回：返回反转链表的头节点
        
        return recur(head, None)       # 调用递归并返回
```

**复杂度分析**：
- 时间复杂度$O(N)$：N为链表长度
- 空间复杂度$O(N)$：递归深度为N

## 删除节点

思路：
1. 找到要删除的目标节点
2. 断开 `pre` 的链接
3. 更新 `pre` 的连接

添加细节：
1. **特殊情况**：当目标节点为 `head` 时，直接返回 `head.next`
2. **一般情况**
	1. **初始化**：双指针 `pre=head` ， `cur=head.next`
	2. **寻找节点**：当 `cur` 为null，或者 `cur.val == val` 时停止循环
		1. 保存当前节点，`pre=cur`
		2. 更新当前节点，`cur=cur.next`
	3. **删除节点**：若 `cur` 指向null，说明链表无目标节点；若 `cur` 指向目标节点，此时跳出循环且 `cur` 为真，则执行 `pre.next = cur.next`
	4. **返回值**：返回链表头部

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, head: ListNode, val: int) -> ListNode:
        if head.val == val: return head.next
        pre, cur = head, head.next
        while cur and cur.val != cur:
            pre = cur
            cur = cur.next
        if cur: pre.next =cur.next
        return head
```

**复杂度分析**：
- 时间复杂度$O(N)$：N为链表长度，最差情况需要一直查找至链表末端
- 空间复杂度$O(1)$：双指针占用常数大小额外空间

## 查找倒数第 `cnt` 个节点

思路：不考虑越界
1. 初始化双指针pre和cur
2. cur先更新cnt次，让pre与cur之间相隔cnt个节点
3. 循环更新cur直到cur指向null
4. 此时pre即为目标节点

```python
class Solution:
    def trainingPlan(self, head: ListNode, cnt: int) -> ListNode:
        former, latter = head, head
        for _ in range(cnt):
	        if not former: return # 考虑越界，先判断former指针有没有提前指向null
            former = former.next
        while former:
            former, latter = former.next, latter.next
        return latter
```

**复杂度分析**：
- 时间复杂度$O(N)$：N为链表长度
- 空间复杂度$O(1)$：双指针使用常数大小空间

## 合并有序链表

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

思路：
- 建立第三个链表l3用以存储合并链表
- 双指针分别访问链表1和链表2
- 对指针指向节点val进行比较，将较小的链表此时的节点接入l3，并更新该链表
- 更新链表l3
- 循环直至链表1和2有一方为空，跳出循环
- 如果此时有一方链表没有访问完毕，则直接将该链表接入l3
- 返回head.next

```python
class Solution:
    def trainningPlan(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    l3 = ListNode() # 建立中转节点
    head = l3 # 存储表头用以返回合并后的链表头
	while l1 and l2: # 
		if l1.val <= l2.val:
			l3.next = l1
			l1 = l1.next
		else:
			l3.next = l2
			l2 = l2.next
		l3.next
		
	l3.next = l1 if l1 else l2

	return head.next
```

**复杂度分析**：
- 时间复杂度$O(M+N)$：M，N分别为链表1、2的长度
- 空间复杂度$O(1)$：双指针使用常数大小的空间

## 相交链表

寻找链表的相交节点（只考虑一定有相交节点的情况）

- 记链表A、B长度分别为a、b
- 记公共部分长度为n
- 则链表A、B中节点个数为a+b-n

思路：
- 建立双指针headA、headB分别访问A、B
- 令指针headA访问链表A，当链表A访问完毕则开始访问链表B；指针headB同理，访问链表B再访问链表A
- 当两个指针第一次指向同一个位置时，即为公共节点，两个指针访问过的节点正好为a+b-n

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        A, B = headA, headB
        while A != B:
            A = A.next if A else headB
            B = B.next if B else headA
        return A
```

**复杂度分析**：
- 时间复杂度$O(a+b)$：a、b分别为链表A、B的长度
- 空间复杂度$O(1)$：双指针使用常数大小空间

## 复制链表

## 随机链表的复制

- 随机链表定义如下：
```python
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random # 难点在于复制时构建random引用指向
```

- 普通链表的复制：
```python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        cur = head
        dum = pre = Node(0)
        while cur:
            node = Node(cur.val) # 复制节点 cur
            pre.next = node      # 新链表的 前驱节点 -> 当前节点
            # pre.random = '???' # 新链表的 「 前驱节点 -> 当前节点 」 无法确定
            cur = cur.next       # 遍历下一节点
            pre = node           # 保存当前新节点
        return dum.next
```

1. 哈希表

构建**原链表节点**和**新链表对应节点**的键值对映射关系

- 特例：head为空，返回null
- 初始化：哈希表 hmap，节点 cur=head
- 复制链表：
	- 建立新节点，向hmap添加键值对，“原节点 -> 新节点” 的 Map 映射
	- cur遍历下一节点
- 构建引用指向
	- 构建next和random引用
	- cur遍历下一节点
- 返回：`hmap[cur]`

```python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head: return
        hmap = {}
        
        # 3. 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        cur = head
        while cur:
            hmap[cur] = Node(cur.val)
            cur = cur.next
        
        # 4. 构建新节点的 next 和 random 指向
        cur = head
        while cur:
            hmap[cur].next = hmap.get(cur.next)
            hmap[cur].random = hmap.get(cur.random)
            cur = cur.next
        # 5. 返回新链表的头节点
        return hmap[head]
```

**复杂度分析**：
- 时间复杂度$O(N)$：遍历两次链表，与链表长度N线性相关
- 空间复杂度$O(N)$：哈希表hmap使用与链表长度N相关空间大小

2. 拼接+拆分

考虑构建 原节点 1 -> 新节点 1 -> 原节点 2 -> 新节点 2 -> …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。

算法流程：
- 复制各节点，构建拼接链表
	- 原链表：node1 -> node2 -> ...
	- 拼接链表：node1 -> node1_new -> node2 -> node2_new -> ...
- 构建新链表各节点的 `random` 指向
	- 原链表：cur -> cur.random
	- 新链表：cur.next -> cur.random.next
- 拆分拼接链表
	- 设置双指针pre和cur分别指向原链表和新链表头
	- 执行：
		- pre.next = pre.next.next
		- cur.next = cur.next.next
- 返回：新链表头节点res

```python
class Solution: 
	def copyRandomList(self, head: 'Node') -> 'Node':
		if not head: return
		# 1. 复制各节点，并构建拼接链表
		cur = head
		while cur:
			tmp = Node(cur.val)
			tmp.next = cur.next
			cur.next = tmp
			cur = tmp.next
		# 2. 构建各新节点的 random 指向
		cur = head
		while cur:
			if cur.random:
				cur.next.random = cur.random.next
			cur = cur.next.next
		# 3. 拆分两链表
		cur = res = head.next
		pre = head
		while cur.next:
			pre.next = pre.next.next
			cur.next = cur.next.next
			pre = pre.next
			cur = cur.next
		pre.next = None # 单独处理原链表尾节点
		return res # 返回新链表头节点
```

**复杂度分析**：
- 时间复杂度$O(N)$：三轮遍历链表，使用$O(N)$时间
- 空间复杂度$O(1)$：节点引用变量使用常数大小额外空间
