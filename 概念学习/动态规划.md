#### 动态规划 Dynamic programming
#动态规划
**动态规划算法**是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或分治）的方式去解决。

##### 什么是动态规划
动态规划：对于子问题重叠的情况特别有效，因为它将子问题的解保存在表格中，当需要某个子问题的解时，直接取值即可。

##### 基本策略
将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些最有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

##### 使用问题
适合用动态规划来解决的问题，具有下面三个特点：
- **最优化原理**
	如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
- **无后效性**
	即某一阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某个状态以后的过程不会影响以前的状态，只与当前状态有关。
- **有重叠子问题**
	即子问题之间不是独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划使用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就没有优势）

##### 求解步骤：
初始状态->|决策1|->...->|决策n|->结束状态
（1）*划分*：按照问题的特征，把问题分为若干阶段。注：划分后的阶段一定是有序的或者可排序的。
（2）*确定状态和状态变量* ：将问题发展到各个阶段时所处的各种不同的客观情况表现出来。状态选择要满足无后续性。
（3）*确定决策并写出状态转移方程*：状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段之间的联系来确定决策方法和状态转移方程。
（4）*边界条件*：状态转移方程是一个递推式，因此需要找到递推终止的条件

##### 算法实现
动态规划三要素：
（1）问题的阶段
（ 2）每个阶段的状态
（3）相邻两个阶段之间的递推关系
最优决策表（二维表）：*行表示决策阶段*，*列表示问题的状态*
例如：$f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}$

#### 实例1：背包问题
问题描述：假设我们有n种类型的物品，分别编号为1，2，...，n。其中编号为i的物品价值为vi，它的重量为wi。为了简化问题，假定价值和重量都是整数值。现在，假设我们有一个背包，它能够承载的重量是Cap。我们希望往书包里装这些物品，使得包里装的物品价值最大化，那么我们该如何来选择装的东西呢？注意：每种物品只有一件，可以选择放或者不放。初始化数据为：n=5，w={2，2，6，5，4}，v={6，3，5，4，6}，Cap=10
*解答：*
1. 描述最优解的结构
	设子问题：f(i, v)表示允许前i件物品放入容量为v的背包时可以获得的最大价值。注这里i从0到5，v从0到10
	为了能够得到已经计算过的，更小规模的子问题，我们可以根据当前限重来考虑第i件物品放或者不放，那么就可以转化为涉及前i-1件物品的问题。
	即：
	*情况1*： 如果第i件物品不能放（即这个物品直接大于了当前限重），则问题转化为“前i-1件物品放入容量为v的背包中”，即f(i-1, v)
	*情况2*：如果放第i件物品时可以放也可以不放，则问题转化为：
		（1）如果不放，问题转化为f(i-1, v)
		（2）如果放，则问题转化为f(i, v) = f(i-1, v-w(i)) + v(i)
		最优子结构描述如下：当子问题f(i, v)是最优时，其子问题f(i-1, v)和f(i-1, v-wi)中的较大者显然同样也必须是最优解
2. 递归定义最优解的值
情况1：f(i, v) = f(i-1, v)
情况2：f(i, v) = max{f(i-1, v),  f(i-1, v-wi)+v(i)}（需要考虑放i和不放i能达到的最优）
3. 自底而上的方式计算最优解的值
```python
import numpy as np

# 行李数n（决策步骤），不超过的重量W（问题的状态），重量列表w和价值列表p
def fun(n, W, w, p):
	a = np.array([[0]*(W+1)] * (n+1))
	# 依次计算前i个行李的最大价值，n+1在n的基础上进行
	for i in range(1, n+1):# 第几行意味着该行为第几步
		for j in range(1, W+1):# 第几列意味着该列最大限重为对应的列数j
			if w[i-1]>j:
				a[i, j] = a[i-1, j]
			else:
				a[i, j] = max(a[i-1, j], p[i-1]+a[i-1, i-w[i-1]]) # 两种情况取最大值
	print('max value is '+ str(a[n, w]))
	findDetail(p, n, a[n, W])
# 找到价值列表中的一个子集，使得其和等于前面求出的最大价值，即为选择方案
def findDetail(p, n, v):
	a = np.array([[True] *(v+1)] *(n+1))
	for i in range(0, n+1):
		a[i][0] = True
	for i in range(1, v+1):
		a[0][i] = False
	for i in range(1, n+1):
		if p[i-1]>j:
			a[i, j] = a[i-1, j]
		else:
			a[i, j] = a[i-1, j] or a[i-1, j-p[i-1]]
	if a[n, v]:
		i = n
		result = []
		while i>=0:
			if a[i, v] and not a[i-1, v]:
				result.append(p[i-1])
				v-=p[i-1]
			if v==0:
				break
			i-=1
		print(result)
	else:
		print('error')
weights = [1,2,5,6,7,9]
price = [1,6,18,22,28,36]
fun(len(weights), 13, weights, price)
```



>>>参考连接：
>>>	[# 详解动态规划算法（Python实现动态规划算法典型例题）](https://blog.csdn.net/SweetSeven_/article/details/95466195)